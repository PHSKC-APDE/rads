#' Generate synthetic data for use in public sharing or testing
#'
#' @description
#' Receives a data table of public health data and returns a synthetic version that is identically structured but uncorrelated. User may request results as a DT or as code that will generate the data once executed.
#'
#' @param ph.data a data.table or data.frame containing the data to be age-standardized.
#' @param number_of_observations Character vector of any length or integer greater than 1. Strings will appear in code as a variable, integers as an integer. If requesting output as data, must be an integer.
#' @param comments Logical vector of length 1. Indicate if code should include comments. Comments describe how each column was defined.
#' @param return_code Logical vector of length 1. Indicates if the user wants the function to return a data.table containing lists of strings of code used to model the data (TRUE) or a data.table of the synthetic data (FALSE)
#' @param print_code Logical vector of length 1. Indicates if the code generated by the modeler should be printed to console.
#' Note, if you with to copy and paste the code for use in your own work, it is recommended to use this console output.
#'
#' @return Outputs code block to terminal and if (return_code = FALSE) returns a DT of the synthetic data. If (return_code = TRUE) returns a DT of character vectors used to create the code strings. If (comments = TRUE) code will include comments describing the data type of each column.
#'
#' @export
#' @name data_modeler
#' @references \url{CREATE A WIKI FOR THIS}
#' @examples
#' \donttest{
#' # Observe that modelled data looks like original data
#' library(data.table)
#' ph.data <- get_data_birth(cols = c('race4', 'chi_age', 'hra20_name', 'sex', 'birth_weight_grams'))
#' DT.synthetic.data <- data_modeler(ph.data = ph.data, number_of_observations =  10000, comments = TRUE, return_code = F, print_code = F)
#'
#' str(ph.data)
#' str(DT.synthetic.data)
#'
#'
#' # Manually convert received code into data
#'
#' DT.code <- data_modeler(ph.data = ph.data, number_of_observations =  10000, comments = TRUE, return_code = T, print_code = T)
#' codeListParsed <- c(list("DT <- data.table("),gsub(" #", ", #", DT.code[1:(length(DT.code)-1)]), gsub(" #",") #",DT.code[length(DT.code)]))
#' codeText <- paste(unlist(codeListParsed), collapse =" \n" )
#' DT.synthetic.data.manual <- eval( parse(text = paste0(codeText)))
#'
#' str(ph.data)
#' str(DT.synthetic.data.manual)
#' }
#'
#' @import data.table rads.data
#'

data_modeler <- function(ph.data, number_of_observations, comments = TRUE, return_code = FALSE, print_code = TRUE) {
  ### generates a synthetic data set appropriate for testing functions relying on APDE data structures and where you do not want to use real data
  ### receives description of data set to emulate, number of observations to include, a seed and number of years.
  ### returns a data.table of synthetic data. If dataset is "generic" the returned structure will have idealized chi values and generic indicators

  ph.data <- data.table::as.data.table(ph.data)

  if(inherits(number_of_observations, "character") & return_code == FALSE) {
    number_of_observations <- as.integer(number_of_observations)
    if(is.na(number_of_observations)) {
      stop("user has requested data, but 'number_of_observations' could not be coerced to an integer. 'number_of_observations' must be an integer.")
    }
    if(number_of_observations <= 0) {
      stop("number_of_observations must be an integer greater than 0")
    }
  }

  variable_modeler <- function(oneVariable, number_of_observations, varName = NA, comments = TRUE) {
    if(any(class(oneVariable) %in% "data.table")) {
      if(ncol(oneVariable) == 1) {
        message(class(oneVariable))
        oneVariable <- oneVariable[,1][[1]]
        message(class(oneVariable))
        message("caught DT")
      } else {
        stop("more than 1 column passed. Only pass a vector or one column")
      }
    }

    instructions <- NA

    if(is.na(varName)){
      variableName <- sub(".*\\$.*?", "\\1", deparse(substitute(oneVariable)))
    } else {
      variableName <- varName
    }

    oneVariableClass <- class(oneVariable)

    #factor
    if(is.na(instructions) & inherits(oneVariable, "factor")) {
      orderTF <- is.ordered(oneVariable)
      detectedLevels <- levels(oneVariable)
      instructions <- paste0("`",variableName,"`"," = factor(sample(c('",paste0(unlist(unique(oneVariable)),collapse = "', '"),"'), ", number_of_observations,", replace = TRUE, prob = c(",paste0(prop.table(table(oneVariable, useNA = 'ifany')), collapse = ", "),")), levels = c('",paste0(detectedLevels, collapse = "', '"),"'), ordered = ", orderTF,")", collapse = "")
      instructions <- gsub("'NA'", "NA", instructions)
      if(comments){
        instructions <- paste0(instructions, " # as a factor")
      }
    }

    #integer: categorical
    if(is.na(instructions) & inherits(oneVariable, "integer") & (length(unique(oneVariable)) <= 61 & length(oneVariable) > 61)) {
      instructions <- paste0("`",variableName,"`"," = as.integer(sample(c('",paste0(unlist(unique(oneVariable)),collapse = "', '"),"'), ", number_of_observations,", replace = TRUE, prob = c(",paste0(prop.table(table(oneVariable, useNA = 'ifany')), collapse = ", "),")))", collapse = "")
      instructions <- gsub("'NA'", "NA", instructions)
      if(comments){
        instructions <- paste0(instructions, " # as a categorical non factor")
      }
    }

    #character: categorical
    if(is.na(instructions) & inherits(oneVariable, "character") & (length(unique(oneVariable)) <= 61 & length(oneVariable) > 61)) {
      instructions <- paste0("`",variableName,"`"," = sample(c('",paste0(unlist(unique(oneVariable)),collapse = "', '"),"'), ", number_of_observations,", replace = TRUE, prob = c(",paste0(prop.table(table(oneVariable, useNA = 'ifany')), collapse = ", "),"))", collapse = "")
      instructions <- gsub("'NA'", "NA", instructions)
      if(comments){

        instructions <- paste0(instructions, " # as a categorical non factor")
      }
    }

    #continuous integer
    if(is.na(instructions) & inherits(oneVariable, "integer") & (length(unique(oneVariable)) > 61 & length(oneVariable) > 61)) {
      #uniform distribution
      instructions <- paste0("`",variableName,"`", " = as.integer(runif(", number_of_observations,", ", min(oneVariable, na.rm = TRUE), ", ", max(oneVariable, na.rm = TRUE),"))")
      if(comments){
        instructions <- paste0(instructions, " # continuous integer with uniform distribution")
      }
    }

    #continuous double
    if(is.na(instructions) & inherits(oneVariable, "double") & (length(unique(oneVariable)) > 61 & length(oneVariable) > 61)) {
      count_decimal_places <- function(x) {
        if (!is.numeric(x)) return(NA)
        sapply(x, function(num) {
          if (is.na(num)) return(NA)
          str_num <- as.character(num)
          if (grepl("\\.", str_num)) {
            return(nchar(strsplit(str_num, "\\.")[[1]][2]))
          } else {
            return(0)
          }
        })
      }
      oneVariable[,RH := count_decimal_places(oneVariable[[1]])]
      numberOfDecimals <- max(oneVariable$RH, na.rm = T)
      #uniform distribution
      instructions <- paste0("`",variableName,"`", " = as.double(round(runif(", number_of_observations,", ", min(oneVariable, na.rm = TRUE), ", ", max(oneVariable, na.rm = TRUE),"),", numberOfDecimals , "))")
      if(comments){
        instructions <- paste0(instructions, " # continuous double with uniform distribution")
      }
    }

    #if unmatched
    if(is.na(instructions)) {

      instructions <- paste0("`",variableName,"`", " = as.integer(NA)")
      if(comments){
        instructions <- paste0(instructions, " # data type not modeled")
      }
    }

    if(is.na(instructions)) {

    } else{
      return(instructions)
    }
  }

  batch_variable_modeler <- function(x) {
    variable_modeler(ph.data[,..x][[1]], number_of_observations, names(ph.data)[x], comments = comments)
  }

  codeList <- lapply(seq_along(ph.data), batch_variable_modeler)

  if(comments) {

    codeListParsed <- c(list("DT <- data.table("),gsub(" #", ", #", codeList[1:(length(codeList)-1)]), gsub(" #",") #",codeList[length(codeList)]))

    codeText <- paste(unlist(codeListParsed), collapse =" \n" )

  } else {
    codeListParsed <- c(list("DT <- data.table("),paste0(codeList[1:(length(codeList)-1)], ","), paste0(codeList[length(codeList)], ")"))

    codeText <- paste(unlist(codeListParsed), collapse =" \n" )
  }

  if(return_code) {
    #codeText <- paste(unlist(codeList), collapse =" \n" )

    cat(codeText)
    return(codeList)

  } else {

    cat(codeText)
    eval( parse(text = paste0(codeText)))
    #  eval( parse(text = paste0("DT <- data.table(", codeText,collapse =  "")))
    return(DT)
  }

}

