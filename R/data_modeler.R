#' Generate synthetic data for use in public sharing or testing
#'
#' @description
#' Receives a data table of public health data and returns a synthetic version that is identically structured but uncorrelated. User may request results as a data.table or as code that will generate the data once executed.
#'
#' @param ph.data a data.table or data.frame to model synthetic data on.
#' @param number_of_observations integer >= 1. Sets the number of observations to create in the synthetic data
#' @param comments logical vector of length 1. Indicate if code should include comments. Comments describe how each column was defined.
#' @param return_code logical vector of length 1. Indicates if the user wants the function to return a list of code strings used to model the data (TRUE) or a data.table of the synthetic data (FALSE)
#' @param print_code logical vector of length 1. Indicates if the code generated by the modeler should be printed to console. Note, if you wish to copy and paste the code for use in your own work, it is recommended to use this console output.
#' @param categorical_threshold integer >= 1. Threshold for the number of unique values in a variable at or below which data_modeler() will treat the value as cateogircal, default 61.
#' @param proportional_threshold floating point between 0 and 1 incusive. Threshold for the proportion of observations that must be unique, below which data modeler() will treat the value as categorical, default 0.75
#'
#' @return When `return_code = FALSE`, returns a data.table containing synthetic data with the same structure as `ph.data`. When `return_code = TRUE`, returns a list of character strings that can be evaluated to generate the synthetic data. If `print_code = TRUE`, the generated code is also printed to the console. If `comments = TRUE`, code will include comments describing the data type of each column.
#' @details
#' `data_modeler()` receives a data.table object and returns a data.table of similar structure and content, but with uncorrelated data across columns. For example, a column of dates will become a column of dates of a similar range, and distribution, but randomly distributed across observations. Common use cases include:
#' A) demonstrating a statistic or visualization without exposing the audience to "real" data or results
#' B) sharing code that generates a data set for minimally viable examples used in requesting help from, or teaching, others
#' C) creating data sets programmatically for (unit) testing or trainin
#'
#' There are two kinds of output that `data_modeler()` returns, either the data table itself, or a list of strings that can be evaluated to create the data.table. In addition, `data_modeler()` can output-to-terminal a human readable version of the generation code that the user can copy and paste into their own scripts for sharing publicly.
#'
#' `data_modeler()` makes some guesses as to if a column's content should be randomized (such as person names or blood pressures) or kept but randomly distributed (such as levels of response to a question or city names). This is intended to generate random data or to retain original categories where appropriate. It bases these guesses on the data type (integer or string), and complexity (e.g. 75% being unique data), but not the meaning of the data (i.e. it doesn't know that a number is a "zip code" and doesn't know that a string is a "human name"). Variables that are identified as non-categorical will, in most cases, be replaced with a uniform distribution of noisy, but similarly shaped, data (e.g. floating point numbers of the same range and precision, but in a random uniform distribution, or a "lore ipsum" string of similar lengths). Variables identified as categorical will, in most cases, be replaced with identical categories in a similar distribution to the original, but randomly assigned across observations (e.g., a data set of 95% males and 5% females would still generate a data set of roughly 95% males and 5% females).
#'
#' Two parameters are available to adjust the assumptions data_modeler uses to identify categorical values. These are "categorical_threshold" and "proportional_threshold".
#' 1) "categorical_threshold": defines how many unique categories can exist in the variable before data_modeler assumes the variable isn't categorical. Above this number, and the value will not be considered categorical. This currently defaults to 61.
#' 2) "proportional_threshold": defines the proportion of values that can be unique before data_modeler() assumes the variable isn't categorical. This currently defaults to 0.75.
#'
#' Each time data_modeler is executed, there is a randomness to how the data are created. If you wish to create identical data sets, be sure to set seed before executing.
#'
#' A warning about data privacy:
#'
#' `data_modeler()` creates an uncorrelated column of data to substitute the original by randomly reassigning values across that column. However, this does not ensure that meaningful information is not passed along. Note that, in most cases, categorical observations are distributed in proportion to the source data. So, if the provided data set is of categorical outcomes in a single population, the uncorrelated result would still show a similar rate of that outcome in that population because all observations would be for the same population group. The analyst should consider if this is acceptable or not and take measures to correct if necessary by either changing the input data or modifying the synthetic data. A simple approach in the above example would be to add one or more additional population groups so that the outcomes would be distributed removing the ability to estimate the rate for the smaller population (in an uncorrelated result, the rate of the categorical outcome would tend to be similar in all populations.)
#'
#' @export
#' @name data_modeler
#' @references \url{https://github.com/PHSKC-APDE/rads/wiki/utilities#data_modeler}
#'
#' @examples
#' \donttest{
#'   library(data.table)
#'   observations <- 1000
#'   ph.data <- data.table(
#'   id = 1:observations,
#'   chi_geo_kc = sample(c('King County',NA_character_), observations, replace = T),
#'   chi_race_7 = factor(sample(c("Asian", "AIAN", "Black", "Hispanic", "NHPI", "White", "Other", "Multiple", NA), observations, replace = T, prob = c(.19,.01,.07,.11,.01,.35,.07,.14,.02)), levels = c("Asian", "AIAN", "Black", "Hispanic", "NHPI", "White", "Other", "Multiple", NA)),
#'   chi_sex = as.factor(sample(c("Male","Female"), observations, replace = T)),
#'   chi_geo_region = factor(sample(c("South", "North", "Seattle", "East"), observations, replace = T), levels = c("South","North","Seattle","East")),
#'   indicator1 = as.factor(sample(c("never","sometimes", "always", NA), observations, replace = T)))
#'
#'   ##Observe that modeled data have the same structure as the original
#'   DT.synthetic.data <- data_modeler(ph.data = ph.data,
#'                                    number_of_observations =  10000,
#'                                    comments = TRUE,
#'                                    return_code = FALSE,
#'                                    print_code = FALSE)
#'   str(ph.data)
#'   str(DT.synthetic.data)
#'
#'
#'   ## Manually convert received code into data
#'   DT.code <- data_modeler(ph.data = ph.data,
#'                                     number_of_observations =  10000,
#'                                     comments = TRUE,
#'                                     return_code = TRUE,
#'                                     print_code = TRUE)
#'   codeText <- paste(unlist(DT.code), collapse =" \n" )
#'   DT.synthetic.data.manual <- eval( parse(text = paste0(codeText)))
#'   str(ph.data)
#'   str(DT.synthetic.data.manual)
#' }
#'
#' @keywords synthetic data

data_modeler <- function(ph.data, number_of_observations = 100, comments = TRUE, return_code = FALSE, print_code = TRUE, categorical_threshold = 61, proportional_threshold = 0.75) {
  ### generates a synthetic data set appropriate for testing functions relying on tabular data structures where you do not want to use real data (e.g. sharing methods where the data from the project are sensitive).
  ### receives data.table object to emulate.
  ### returns a data.table of synthetic data.

  # Validate inputs ----
  if(missing(ph.data)){stop('\n\U1F6D1 ph.data must be provided')}

  if (is.data.frame(ph.data)) {
    data.table::setDT(ph.data)
  } else {
    stop(paste0("\n\U1F6D1 ph.data must be a data.table or data.frame."))
  }

  for (arg_name in c("comments", "return_code", "print_code")) {
    arg_value <- get(arg_name)
    if(!is.logical(arg_value)) {
      stop("\n\U1F6D1 The `", arg_name, "` argument must be a logical, i.e., TRUE | FALSE")
    }
    if(length(arg_value) != 1) {
      stop("\n\U1F6D1 The `", arg_name, "` argument must be of length 1")
    }
  }

  if(inherits(number_of_observations, "character")) {
    number_of_observations <- as.integer(number_of_observations)
    if(is.na(number_of_observations)) {
      stop("user has requested data, but 'number_of_observations' could not be coerced to an integer. 'number_of_observations' must be an integer.")
    }
    if(number_of_observations <= 0) {
      stop("number_of_observations must be an integer greater than 0")
    }
  }


  # convert provided vector into an executable string that generates similar looking data ----
  variable_modeler <- function(oneVariable, number_of_observations, varName = NA, comments = TRUE, categorical_threshold, proportional_threshold) {
    ### receives a single vector or column from a DT
    ### returns a string that, if executed, would create a similarly structured variable of the same name

    count_decimal_places <- function(x) {
      ### receives a vector of numbers
      ### returns the level of precision (maxium number of decimal places observed) in the vector

      if (!is.numeric(x)) return(NA)
      sapply(x, function(num) {
        if (is.na(num)) return(NA)
        str_num <- as.character(num)
        if (grepl("\\.", str_num)) {
          return(nchar(strsplit(str_num, "\\.")[[1]][2]))
        } else {
          return(0)
        }
      })
    }

    if(any(class(oneVariable) %in% "data.table")) {
      if(ncol(oneVariable) == 1) {
        message(class(oneVariable))
        oneVariable <- oneVariable[,1][[1]]
      } else {
        stop("more than 1 column passed. Only pass a vector or one column")
      }
    }

    instructions <- NA


    if(is.na(varName)) {
      variableName <- sub(".*\\$.*?", "\\1", deparse(substitute(oneVariable)))
    } else {
      variableName <- varName
    }

    # factors:
    if(inherits(oneVariable, "factor")) {
      #generic factor replication. For any factor, mirror the probability of its levels. If ordered, reproduce the orders.
      if(is.na(instructions)) {
        orderTF <- is.ordered(oneVariable)
        detectedLevels <- levels(oneVariable)
        instructions <- paste0('`',variableName,'`',' = factor(sample(c("',paste0(unlist(unique(oneVariable)),collapse = '", "'),'"), ', number_of_observations,', replace = TRUE, prob = c(',paste0(prop.table(table(oneVariable, useNA = 'ifany')), collapse = ', '),')), levels = c("',paste0(detectedLevels, collapse = '", "'),'"), ordered = ', orderTF,')', collapse = '')
        instructions <- gsub('"NA"', 'NA', instructions)
        if(comments) {
          instructions <- paste0(instructions, ' # as factor')
        }
      }
    }

    # integers:
    if(inherits(oneVariable,"integer")) {
      # categorical integers:
      # if all are unique, treat as an ID and recreate as a vector of i to N with i being the lowest value in the data, and N being number of observations to be synthesized
      if(is.na(instructions) & (length(unique(oneVariable)) == length(oneVariable))) {
        bottom <- min(oneVariable)
        top <- bottom +(number_of_observations-1)
        instructions <- paste0("`",variableName,"`"," = as.integer(",bottom,":",top,")", collapse = "")
        instructions <- gsub('"NA"', 'NA', instructions)
        if(comments){
          instructions <- paste0(instructions, " # as an identifying (all unique) integer")
        }
      }
      # assumed to be descriptive/indicator values if there are "categorical threshold" or fewer unique items on a vector with "categorical threshold" or more rows
      # these are reapplied with probability matching the proportion of each variable
      if(is.na(instructions) &
         ((length(unique(oneVariable)) <= categorical_threshold & length(oneVariable) >= categorical_threshold) )) {
        instructions <- paste0("`",variableName,"`"," = as.integer(sample(c('",paste0(unlist(unique(oneVariable)),collapse = "', '"),"'), ", number_of_observations,", replace = TRUE, prob = c(",paste0(prop.table(table(oneVariable, useNA = 'ifany')), collapse = ", "),")))", collapse = "")
        instructions <- gsub('"NA"', 'NA', instructions)
        if(comments){
          instructions <- paste0(instructions, " # as categorical integer (non factor)")
        }
      }

      # continuous integer:
      # assumed to be if there are more than "categorical threshold" items on a vector with "categorical threshold" or more rows
      # AND
      # all values are not unique
      # these are reapplied in a defined distribution between the minimum and maximum of the range
      if(is.na(instructions) &
         ((length(unique(oneVariable)) > categorical_threshold) & (length(unique(oneVariable)) != length(oneVariable)))) {
        #uniform distribution
        instructions <- paste0("`",variableName,"`", " = as.integer(runif(", number_of_observations,", ", min(oneVariable, na.rm = TRUE), ", ", max(oneVariable, na.rm = TRUE),"))")
        if(comments) {
          instructions <- paste0(instructions, " # as continuous integer with uniform distribution")
        }
      }
    }

    #doubles:
    if(inherits(oneVariable, "double")) {
      #continuous double:
      # assumed to be if there are more than "categorical threshold" items on a vector with "categorical threshold" or more rows
      # AND
      # all values are not unique
      # these are reapplied in a defined distribution between the minimum and maximum of the range
      if(is.na(instructions) &
         ((length(unique(oneVariable)) > categorical_threshold) & (length(unique(oneVariable)) != length(oneVariable)))) {
        #used to recreate the number of decimal places accurately
        numberOfDecimals <- max(count_decimal_places(oneVariable))
        #uniform distribution
        instructions <- paste0("`",variableName,"`", " = as.double(round(runif(", number_of_observations,", ", min(oneVariable, na.rm = TRUE), ", ", max(oneVariable, na.rm = TRUE),"),", numberOfDecimals , "))")
        if(comments) {
          instructions <- paste0(instructions, " # as continuous double with uniform distribution")
        }
      }
    }

    # if not int or double, try numeric
    if(inherits(oneVariable, "numeric")){
      # categorical numeric:
      # if all are unique, treat as an ID and recreate as a vector of i to N with i being the lowest value in the data, and N being number of observations to be synthesized
      if(is.na(instructions) & (length(unique(oneVariable)) == length(oneVariable))) {
        bottom <- min(oneVariable)
        top <- bottom +(number_of_observations-1)
        instructions <- paste0("`",variableName,"`"," = as.numeric(",bottom,":",top,")")
        instructions <- gsub('"NA"', 'NA', instructions)
        if(comments){
          instructions <- paste0(instructions, " # as an identifying (all unique) numeric")
        }
      }
      # assumed to be descriptive/indicator values if there are "categorical threshold" or fewer unique items on a vector with "categorical threshold" or more rows
      # these are reapplied with probability matching the proportion of each variable
      if(is.na(instructions) &
         ((length(unique(oneVariable)) <= categorical_threshold & length(oneVariable) >= categorical_threshold) )) {
        instructions <- paste0("`",variableName,"`"," = as.numeric(sample(c(",paste0(unlist(unique(oneVariable)),collapse = ", "),"), ", number_of_observations,", replace = TRUE, prob = c(",paste0(prop.table(table(oneVariable, useNA = 'ifany')), collapse = ", "),")))", collapse = "")
        instructions <- gsub('"NA"', 'NA', instructions)
        if(comments){
          instructions <- paste0(instructions, " # as categorical numeric (non factor)")
        }
      }

      #continuous numeric:
      # assumed to be if there are more than "categorical threshold" items on a vector with "categorical threshold" or more rows
      # AND
      # all values are not unique
      # these are reapplied in a defined distribution between the minimum and maximum of the range
      if(is.na(instructions) &
         ((length(unique(oneVariable)) > categorical_threshold) & (length(unique(oneVariable)) != length(oneVariable)))) {
        #used to recreate the number of decimal places accurately
        numberOfDecimals <- max(count_decimal_places(oneVariable))
        #uniform distribution
        instructions <- paste0("`",variableName,"`", " = as.numeric(round(runif(", number_of_observations,", ", min(oneVariable, na.rm = TRUE), ", ", max(oneVariable, na.rm = TRUE),"),", numberOfDecimals , "))")
        if(comments) {
          instructions <- paste0(instructions, " # as continuous numeric with uniform distribution")
        }
      }


    }

    #characters:
    if(inherits(oneVariable, "character")){
      # categorical characters:
      # assumed if there are "categorical threshold" or fewer unique items in a vector OR if the vector is less than "proportional threshold" unique
      # the categories are reapplied with probability matching the proportion of each variable
      if(is.na(instructions) & (length(unique(oneVariable)) <= categorical_threshold | length(unique(oneVariable)) < (length(oneVariable) * proportional_threshold))){
        instructions <- paste0('`',variableName,'`',' = sample(c("',paste0(unlist(unique(oneVariable)),collapse = '", "'),'"), ', number_of_observations,', replace = TRUE, prob = c(',paste0(prop.table(table(oneVariable, useNA = 'ifany')), collapse = ', '),'))', collapse = '')
        instructions <- gsub('"NA"', 'NA', instructions)
        if(comments){
          instructions <- paste0(instructions, ' # as categorical character (non factor)')
        }
      }

      # numeric characters:
      # assumed if there are more than "categorical threshold" observations, and "proportion threshold" or more are unique
      # and they cleanly convert to numeric
      # replaced with numeric of range with uniform distribution
      if(is.na(instructions) &
         (length(unique(oneVariable)) >= (length(oneVariable) * proportional_threshold)) &
         sum(is.na(oneVariable)) == sum(is.na(suppressWarnings(as.numeric(oneVariable))))) {
        startNum <- min(suppressWarnings(as.numeric(oneVariable)))
        endNum <- max(suppressWarnings(as.numeric(oneVariable)))

        #add function to count number of decimals and rate of changecan be adjusted
        byNum <- .01
        decLength <- 2

        instructions <- paste0('`',variableName,'`',' = as.character(sample(sprintf("%.', decLength ,'f",seq(', startNum, ', ',endNum,', by = ', byNum,')), ', number_of_observations,', replace = TRUE))', collapse = '')
        instructions <- gsub('"NA"', 'NA', instructions)
        if(comments){
          instructions <- paste0(instructions, ' # as numeric looking character')
        }
      }

      # miscellaneous characters (free text):
      # assumed if there are more than "categorical threshold" observations and "proportional threshold" or more are unique
      # and they do not cleanly convert to numeric
      # replaced with "lorem ipsum" of length similar to source
      if(is.na(instructions) &
         (length(unique(oneVariable)) >= (length(oneVariable) * proportional_threshold)) &
         sum(is.na(oneVariable)) != sum(is.na(suppressWarnings(as.numeric(oneVariable))))) {
        #arbitrarily long lorem ipsum to be pared down for expore. May need ot be bigger if paragraph length text are passed to this function
        loremipsum <- "Lorem ipsum dolor sit amet consectetur adipiscing elit. Pretium tellus duis convallis tempus leo eu aenean. Iaculis massa nisl malesuada lacinia integer nunc posuere. Conubia nostra inceptos himenaeos orci varius natoque penatibus. Nulla molestie mattis scelerisque maximus eget fermentum odio."
        minimumLength <- min(nchar(oneVariable))
        maximumLength <- max(nchar(oneVariable))

        LIsplit <- paste0(strsplit(loremipsum, split = "")[[1]][1:maximumLength], collapse = "")
        LIsplit <- strsplit(paste0(strsplit(loremipsum, split = "")[[1]][1:maximumLength], collapse = ""), split = " ")[[1]]
        find.min.parts <- function(minimumLength, LIsplit) {
          minparts <- 0
          for(i in 1:length(LIsplit)) {
            if(nchar(paste0(LIsplit[1:i], collapse = " ")) < minimumLength) {minparts <- minparts +1}
          }
          return(minparts)
        }
        minparts <- find.min.parts(minimumLength, LIsplit)

        instructions <- paste0('`',variableName,'`',' = replicate(',number_of_observations,', sapply(sample(',minparts,':',length(LIsplit),',1), function(x) {paste0(sample(c("',paste0(LIsplit, collapse = '", "'),'"), x, replace = T), collapse = " ")}))', collapse = '')
        if(comments){
          instructions <- paste0(instructions, ' # as character, free text')
        }
      }
    }

    #base R dates:
    if(inherits(oneVariable, "Date")) {
      # if there are 12 or fewer unique dates, create the same dates matching their probability in source
      if(is.na(instructions) & length(unique(oneVariable)) <= 12){

        instructions <- paste0('`',variableName,'`',' = as.Date(sample(c("',paste0(unlist(unique(oneVariable)),collapse = '", "'),'"), ', number_of_observations,', replace = TRUE, prob = c(',paste0(prop.table(table(oneVariable, useNA = 'ifany')), collapse = ', '),')))', collapse = '')
        instructions <- gsub('"NA"', 'NA', instructions)
        if(comments){
          instructions <- paste0(instructions, ' # as Date (with original probability)')
        }
      }

      # if more than 12 dates
      # identify if dates are unique by day, month, or year
      # randomly sample dates between first and last date in uniform distribution
      if(is.na(instructions) & length(unique(oneVariable)) > 12){
        # detect if dates are unique by day, month, or year
        uniqueByType <- "day"
        months <- format(oneVariable, "%Y-%m")
        if(length(unique(months)) == length(unique(oneVariable))) {
          uniqueByType <- "month"
        }
        years <- format(oneVariable, "%Y")
        if(length(unique(years)) == length(unique(oneVariable))) {
          uniqueByType <- "years"
        }
        startDate <- min(oneVariable)
        endDate <- max(oneVariable)

        instructions <- paste0('`',variableName,'`',' = sample(seq(as.Date("', startDate, '"), as.Date("',endDate,'"), by = "', uniqueByType,'"), ', number_of_observations,', replace = TRUE)', collapse = '')
        instructions <- gsub('"NA"', 'NA', instructions)
        if(comments){
          instructions <- paste0(instructions, ' # as Date (with uniform distribution by ', uniqueByType,')')
        }
      }
    }

    # POSIXt:
    # This section initially drafted by copilot, initial review and corrections by RWB
    if(inherits(oneVariable, "POSIXct")){
      # If there are 12 or fewer unique timestamps, sample with original probability
      if(is.na(instructions) & length(unique(oneVariable)) <= 12){

        tz <- attr(oneVariable, "tzone")
        # Format values to full seconds; include timezone in the string for robust parsing
        vals_chr <- format(unique(oneVariable), "%Y-%m-%d %H:%M:%S", usetz = TRUE)

        if(!is.null(tz) && nzchar(tz)){
          instructions <- paste0(
            '`', variableName, '`',
            ' = as.POSIXct(sample(c("',
            paste0(vals_chr, collapse = '", "'),
            '"), ',
            number_of_observations,
            ', replace = TRUE, prob = c(',
            paste0(prop.table(table(oneVariable, useNA = "ifany")), collapse = ', '),
            ')), tz = "', tz, '")'
          )
        } else {
          instructions <- paste0(
            '`', variableName, '`',
            ' = as.POSIXct(sample(c("',
            paste0(vals_chr, collapse = '", "'),
            '"), ',
            number_of_observations,
            ', replace = TRUE, prob = c(',
            paste0(prop.table(table(oneVariable, useNA = "ifany")), collapse = ', '),
            ')))'
          )
        }

        instructions <- gsub('"NA"', 'NA', instructions)
        if(comments){
          instructions <- paste0(instructions, ' # as POSIXct (with original probability)')
        }
      }

      # If more than 12 unique timestamps, detect granularity and sample uniformly
      if(is.na(instructions) & length(unique(oneVariable)) > 12){

        # Detect if timestamps are unique by second, minute, hour, day, month, or year
        uniqueByType <- "sec"
        mins   <- format(oneVariable, "%Y-%m-%d %H:%M")
        if(length(unique(mins))   == length(unique(oneVariable))) uniqueByType <- "min"
        hours  <- format(oneVariable, "%Y-%m-%d %H")
        if(length(unique(hours))  == length(unique(oneVariable))) uniqueByType <- "hour"
        days   <- format(oneVariable, "%Y-%m-%d")
        if(length(unique(days))   == length(unique(oneVariable))) uniqueByType <- "day"
        months <- format(oneVariable, "%Y-%m")
        if(length(unique(months)) == length(unique(oneVariable))) uniqueByType <- "month"
        years  <- format(oneVariable, "%Y")
        if(length(unique(years))  == length(unique(oneVariable))) uniqueByType <- "year"

        startDT <- suppressWarnings(min(oneVariable, na.rm = TRUE))
        endDT   <- suppressWarnings(max(oneVariable, na.rm = TRUE))
        tz <- attr(oneVariable, "tzone")
        start_str <- format(startDT, "%Y-%m-%d %H:%M:%S")
        end_str   <- format(endDT,   "%Y-%m-%d %H:%M:%S")

        if(!is.null(tz) && nzchar(tz)){
          instructions <- paste0(
            '`', variableName, '`',
            ' = sample(seq(as.POSIXct("', start_str, '", tz = "', tz, '"), ',
            'as.POSIXct("', end_str, '", tz = "', tz, '"), ',
            'by = "', uniqueByType, '"), ',
            number_of_observations,', replace = TRUE)'
          )
        } else {
          instructions <- paste0(
            '`', variableName, '`',
            ' = sample(seq(as.POSIXct("', start_str, '"), ',
            'as.POSIXct("', end_str, '"), ',
            'by = "', uniqueByType, '"), ',
            number_of_observations,', replace = TRUE)'
          )
        }

        instructions <- gsub('"NA"', 'NA', instructions)
        if(comments){
          instructions <- paste0(instructions, ' # as POSIXct (with uniform distribution by ', uniqueByType,')')
        }
      }
    }



    # logicals:
    if(inherits(oneVariable,"logical")) {
      # match proportional distribution of source
      instructions <- paste0('`',variableName,'`',' = sample(c("',paste0(unlist(unique(oneVariable)),collapse = '", "'),'"), ', number_of_observations,', replace = TRUE, prob = c(',paste0(prop.table(table(oneVariable, useNA = 'ifany')), collapse = ', '),'))', collapse = '')
      instructions <- gsub('"NA"', 'NA', instructions)
      instructions <- gsub('"FALSE"', 'FALSE', instructions)
      instructions <- gsub('"TRUE"', 'TRUE', instructions)
      if(comments){
        instructions <- paste0(instructions, ' # as logical')
      }
    }

    # unmatched:
    if(is.na(instructions)) {
      # return vector of NA integers
      # if comments, indicate unmodeled data class
      instructions <- paste0("`",variableName,"`", " = as.integer(NA)")
      if(comments){
        instructions <- paste0(instructions, " # [",variableName,"] of class [",paste0(class(oneVariable), collapse =  "], ["),"] not modeled")
      }
    }

    return(instructions)
  }

  # Loop through the core function to model entire DT and parse output
  batch_variable_modeler <- function(x){
    variable_modeler(oneVariable = ph.data[,x, with = F][[1]], number_of_observations =  number_of_observations, varName = names(ph.data)[x], comments = comments, categorical_threshold, proportional_threshold)
  }

  codeList <- lapply(seq_along(ph.data), batch_variable_modeler)


  if(comments) {
    if(length(codeList) == 1) {
      codeListParsed <- c(list("DT <- data.table("),gsub(" #",") #",codeList[length(codeList)]))
    } else {
      codeListParsed <- c(list("DT <- data.table("),gsub(" #", ", #", codeList[1:(length(codeList)-1)]), gsub(" #",") #",codeList[length(codeList)]))
    }
  } else {
    if(length(codeList) == 1) {
      codeListParsed <- c(list("DT <- data.table("),paste0(codeList[length(codeList)], ")"))
    } else {
      codeListParsed <- c(list("DT <- data.table("),paste0(codeList[1:(length(codeList)-1)], ","), paste0(codeList[length(codeList)], ")"))
    }
  }

  codeText <- paste(unlist(codeListParsed), collapse =" \n" )

  # issue warning if any variables were not modeled
  if(grepl("] not modeled" ,codeText)) {
    warning("There are one or more variables that could not be modeled. These will be NA columns in the model data. Review comments (run with comments = TRUE) for additional details")
  }

  if(print_code) {
    cat(codeText)
  }

  if(return_code) {
    return(codeListParsed)
  }else{
    DT <- eval(parse(text = paste0(codeText)))
    return(DT)
  }
}
