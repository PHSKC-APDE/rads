#' Generate synthetic data for use in public sharing or testing
#'
#' @description
#' Receives a data table of public health data and returns a synthetic version that is identically structured but uncorrelated. User may request results as a data.table or as code that will generate the data once executed.
#'
#' @param ph.data a data.table or data.frame.
#' @param number_of_observations Character vector of any length or integer greater than 1. Strings will appear in code as a variable, integers as an integer. If requesting output as data, must be an integer.
#' @param comments Logical vector of length 1. Indicate if code should include comments. Comments describe how each column was defined.
#' @param return_code Logical vector of length 1. Indicates if the user wants the function to return a list of code strings used to model the data (TRUE) or a data.table of the synthetic data (FALSE)
#' @param print_code Logical vector of length 1. Indicates if the code generated by the modeler should be printed to console. Note, if you with to copy and paste the code for use in your own work, it is recommended to use this console output.
#'
#' @return Outputs code block to terminal and if (return_code = FALSE) returns a data.table of the synthetic data. If (return_code = TRUE) returns a list of character vectors used to create the code strings. If (comments = TRUE) code will include comments describing the data type of each column.
#'
#' @export
#' @name data_modeler
#' @references \url{CREATE A WIKI FOR THIS}
#'
#' @import data.table rads.data
#'
#' @examples
#' \donttest{
#'   library(data.table)
#'   ph.data <- data.table(
#'   id = 1:observations,
#'   chi_geo_kc = sample(c('King County',NA_character_), observations, replace = T),
#'   chi_race_7 = factor(sample(c("Asian", "AIAN", "Black", "Hispanic", "NHPI", "White", "Other", "Multiple", NA), observations, replace = T, prob = c(.19,.01,.07,.11,.01,.35,.07,.14,.02)), levels = c("Asian", "AIAN", "Black", "Hispanic", "NHPI", "White", "Other", "Multiple", NA)),
#'   chi_sex = as.factor(sample(c("Male","Female"), observations, replace = T)),
#'   chi_geo_region = factor(sample(c("South", "North", "Seattle", "East"), observations, replace = T), levels = c("South","North","Seattle","East")),
#'   indicator1 = as.factor(sample(c("never","sometimes", "always", NA), observations, replace = T)))
#'
#'   ##Observe that modeled data have the same structure as the original
#'   DT.synthetic.data <- data_modeler(ph.data = ph.data,
#'                                    number_of_observations =  10000,
#'                                    comments = TRUE,
#'                                    return_code = FALSE,
#'                                    print_code = FALSE)
#'   str(ph.data)
#'   str(DT.synthetic.data)
#'
#'
#'   ## Manually convert received code into data
#'   DT.code <- data_modeler(ph.data = ph.data,
#'                                     number_of_observations =  10000,
#'                                     comments = TRUE,
#'                                     return_code = TRUE,
#'                                     print_code = TRUE)
#'   codeText <- paste(unlist(DT.code), collapse =" \n" )
#'   DT.synthetic.data.manual <- eval( parse(text = paste0(codeText)))
#'   str(ph.data)
#'   str(DT.synthetic.data.manual)
#' }
#'

data_modeler <- function(ph.data, number_of_observations = 100, comments = TRUE, return_code = FALSE, print_code = TRUE) {
  ### generates a synthetic data set appropriate for testing functions relying on tabular data structures where you do not want to use real data (e.g. sharing methods where the data from the project are sensitive).
  ### receives data.table object to emulate.
  ### returns a data.table of synthetic data.

  # Global variables used by data.table declared as NULL to make devtools::check() happy ----
  RH <- DT <- `..x` <- NULL

  # Validate inputs ----
  if(missing(ph.data)){stop('\n\U1F6D1 ph.data must be provided')}

  if (is.data.frame(ph.data)) {
    data.table::setDT(ph.data)
  } else {
    stop(paste0("\n\U1F6D1 ph.data must be a data.table or data.frame."))
  }

  for (arg_name in c("comments", "return_code", "print_code")) {
    arg_value <- get(arg_name)
    if(!is.logical(arg_value)) {
      stop("\n\U1F6D1 The `", arg_name, "` argument must be a logical, i.e., TRUE | FALSE")
    }
    if(length(arg_value) != 1) {
      stop("\n\U1F6D1 The `", arg_name, "` argument must be of length 1")
    }
  }

  if(inherits(number_of_observations, "character") & return_code == FALSE) {
    number_of_observations <- as.integer(number_of_observations)
    if(is.na(number_of_observations)) {
      stop("user has requested data, but 'number_of_observations' could not be coerced to an integer. 'number_of_observations' must be an integer.")
    }
    if(number_of_observations <= 0) {
      stop("number_of_observations must be an integer greater than 0")
    }
  }
  # convert provided vector into an executable string that generates similar looking data ----
  variable_modeler <- function(oneVariable, number_of_observations, varName = NA, comments = TRUE) {
    if(any(class(oneVariable) %in% "data.table")) {
      if(ncol(oneVariable) == 1) {
        message(class(oneVariable))
        oneVariable <- oneVariable[,1][[1]]
      } else {
        stop("more than 1 column passed. Only pass a vector or one column")
      }
    }

    instructions <- NA


    if(is.na(varName)) {
      variableName <- sub(".*\\$.*?", "\\1", deparse(substitute(oneVariable)))
    } else {
      variableName <- varName
    }

    # factors:
    if(inherits(oneVariable, "factor")) {
      #generic factor replication. For any factor, mirror the probability of its levels. If ordered, reproduce the orders.
      if(is.na(instructions)) {
        orderTF <- is.ordered(oneVariable)
        detectedLevels <- levels(oneVariable)
        instructions <- paste0('`',variableName,'`',' = factor(sample(c("',paste0(unlist(unique(oneVariable)),collapse = '", "'),'"), ', number_of_observations,', replace = TRUE, prob = c(',paste0(prop.table(table(oneVariable, useNA = 'ifany')), collapse = ', '),')), levels = c("',paste0(detectedLevels, collapse = '", "'),'"), ordered = ', orderTF,')', collapse = '')
        instructions <- gsub("'NA'", 'NA', instructions)
        if(comments) {
          instructions <- paste0(instructions, ' # as factor')
        }
      }
    }

    # integers:
    if(inherits(oneVariable,"integer")) {
      # categorical integers:
      # assumed to be if there are 61 (number of HRAs) or fewer unique items on a vector with 61 or more rows
      # OR
      # if all are unique
      # these are reapplied with probability matching the proportion of each variable
      if(is.na(instructions) &
         ((length(unique(oneVariable)) <= 61 & length(oneVariable) >= 61) | (length(unique(oneVariable)) == length(oneVariable)))) {
        instructions <- paste0("`",variableName,"`"," = as.integer(sample(c('",paste0(unlist(unique(oneVariable)),collapse = "', '"),"'), ", number_of_observations,", replace = TRUE, prob = c(",paste0(prop.table(table(oneVariable, useNA = 'ifany')), collapse = ", "),")))", collapse = "")
        instructions <- gsub("'NA'", "NA", instructions)
        if(comments){
          instructions <- paste0(instructions, " # as categorical integer (non factor)")
        }
      }
      # continuous integer:
      # assumed to be if there are more than 61 (number of HRAs) items on a vector with 61 or more rows
      # AND
      # all values are not unique
      # these are reapplied in a defined distribution between the minimum and maximum of the range
      if(is.na(instructions) &
         ((length(unique(oneVariable)) > 61) & (length(unique(oneVariable)) != length(oneVariable)))) {
        #uniform distribution
        instructions <- paste0("`",variableName,"`", " = as.integer(runif(", number_of_observations,", ", min(oneVariable, na.rm = TRUE), ", ", max(oneVariable, na.rm = TRUE),"))")
        if(comments) {
          instructions <- paste0(instructions, " # as continuous integer with uniform distribution")
        }
      }
    }

    #doubles:
    if(inherits(oneVariable, "double")) {
      #continuous double:
      # assumed to be if there are more than 61 (number of HRAs) items on a vector with 61 or more rows
      # AND
      # all values are not unique
      # these are reapplied in a defined distribution between the minimum and maximum of the range
      if(is.na(instructions) &
         ((length(unique(oneVariable)) > 61) & (length(unique(oneVariable)) != length(oneVariable)))) {
        #used to recreate the number of decimal places accurately
        count_decimal_places <- function(x) {
          if (!is.numeric(x)) return(NA)
          sapply(x, function(num) {
            if (is.na(num)) return(NA)
            str_num <- as.character(num)
            if (grepl("\\.", str_num)) {
              return(nchar(strsplit(str_num, "\\.")[[1]][2]))
            } else {
              return(0)
            }
          })
        }
        oneVariable[,RH := count_decimal_places(oneVariable[[1]])]
        numberOfDecimals <- max(oneVariable$RH, na.rm = T)
        #uniform distribution
        instructions <- paste0("`",variableName,"`", " = as.double(round(runif(", number_of_observations,", ", min(oneVariable, na.rm = TRUE), ", ", max(oneVariable, na.rm = TRUE),"),", numberOfDecimals , "))")
        if(comments) {
          instructions <- paste0(instructions, " # as continuous double with uniform distribution")
        }
      }
    }

    #characters:
    if(inherits(oneVariable, "character")){
      # categorical characters:
      # assumed if there are 61 (number of HRAs) or fewer unique items in a vector OR if the vector is less than 75% unique
      # the categories are reapplied with probability matching the proportion of each variable
      if(is.na(instructions) & (length(unique(oneVariable)) <= 61 | length(unique(oneVariable)) < (length(oneVariable) *.75))){
        instructions <- paste0('`',variableName,'`',' = sample(c("',paste0(unlist(unique(oneVariable)),collapse = '", "'),'"), ', number_of_observations,', replace = TRUE, prob = c(',paste0(prop.table(table(oneVariable, useNA = 'ifany')), collapse = ', '),'))', collapse = '')
        instructions <- gsub("'NA'", "NA", instructions)
        if(comments){
          instructions <- paste0(instructions, ' # as categorical character (non factor)')
        }
      }

      # numeric characters:
      # assumed if there are more than 61 observations, and 75% or more are unique
      # and they cleanly convert to numeric
      # replaced with numeric of range with uniform distribution
      if(is.na(instructions) &
         (length(unique(oneVariable)) >= (length(oneVariable) *.75)) &
         sum(is.na(oneVariable)) == sum(is.na(suppressWarnings(as.numeric(oneVariable))))) {
        startNum <- min(suppressWarnings(as.numeric(oneVariable)))
        endNum <- max(suppressWarnings(as.numeric(oneVariable)))

        #add function to count number of decimals and rate of changecan be adjusted
        byNum <- .01
        decLength <- 2

        instructions <- paste0('`',variableName,'`',' = as.character(sample(sprintf("%.', decLength ,'f",seq(', startNum, ', ',endNum,', by = ', byNum,')), ', number_of_observations,', replace = TRUE))', collapse = '')
        instructions <- gsub("'NA'", "NA", instructions)
        if(comments){
          instructions <- paste0(instructions, ' # as numeric looking character')
        }
      }

      # miscellaneous characters (free text):
      # assumed if there are more than 61 observations, and 75% or more are unique
      # and they do not cleanly convert to numeric
      # replaced with "lorem ipsum" of length similar to source
      if(is.na(instructions) &
         (length(unique(oneVariable)) >= (length(oneVariable) *.75)) &
         sum(is.na(oneVariable)) != sum(is.na(suppressWarnings(as.numeric(oneVariable))))) {
        #arbitrarily long lorem ipsum to be pared down for expore. May need ot be bigger if paragraph length text are passed to this function
        loremipsum <- "Lorem ipsum dolor sit amet consectetur adipiscing elit. Pretium tellus duis convallis tempus leo eu aenean. Iaculis massa nisl malesuada lacinia integer nunc posuere. Conubia nostra inceptos himenaeos orci varius natoque penatibus. Nulla molestie mattis scelerisque maximus eget fermentum odio."
        minimumLength <- min(nchar(oneVariable))
        maximumLength <- max(nchar(oneVariable))

        LIsplit <- paste0(strsplit(loremipsum, split = "")[[1]][1:maximumLength], collapse = "")
        LIsplit <- strsplit(paste0(strsplit(loremipsum, split = "")[[1]][1:maximumLength], collapse = ""), split = " ")[[1]]
        find.min.parts <- function(minimumLength, LIsplit) {
          minparts <- 0
          for(i in 1:length(LIsplit)) {
            if(nchar(paste0(LIsplit[1:i], collapse = " ")) < minimumLength) {minparts <- minparts +1}
          }
          return(minparts)
        }
        minparts <- find.min.parts(minimumLength, LIsplit)

        instructions <- paste0('`',variableName,'`',' = replicate(',number_of_observations,', sapply(sample(',minparts,':',length(LIsplit),',1), function(x) {paste0(sample(c("',paste0(LIsplit, collapse = '", "'),'"), x, replace = T), collapse = " ")}))', collapse = '')
        if(comments){
          instructions <- paste0(instructions, ' # as character, free text')
        }
      }
    }

    #base R dates:
    if(inherits(oneVariable, "Date")) {
      # if there are 12 or fewer unique dates, create the same dates matching their probability in source
      if(is.na(instructions) & length(unique(oneVariable)) <= 12){

        instructions <- paste0('`',variableName,'`',' = as.Date(sample(c("',paste0(unlist(unique(oneVariable)),collapse = '", "'),'"), ', number_of_observations,', replace = TRUE, prob = c(',paste0(prop.table(table(oneVariable, useNA = 'ifany')), collapse = ', '),')))', collapse = '')
        instructions <- gsub("'NA'", "NA", instructions)
        if(comments){
          instructions <- paste0(instructions, ' # as Date (with original probability)')
        }
      }

      # if more than 12 dates
      # identify if dates are unique by day, month, or year
      # randomly sample dates between first and last date in uniform distribution
      if(is.na(instructions) & length(unique(oneVariable)) > 12){
        # detect if dates are unique by day, month, or year
        uniqueByType <- "day"
        months <- format(oneVariable, "%Y-%m")
        if(length(unique(months)) == length(unique(oneVariable))) {
          uniqueByType <- "month"
        }
        years <- format(oneVariable, "%Y")
        if(length(unique(years)) == length(unique(oneVariable))) {
          uniqueByType <- "years"
        }
        startDate <- min(oneVariable)
        endDate <- max(oneVariable)

        instructions <- paste0('`',variableName,'`',' = sample(seq(as.Date("', startDate, '"), as.Date("',endDate,'"), by = "', uniqueByType,'"), ', number_of_observations,', replace = TRUE)', collapse = '')
        instructions <- gsub("'NA'", "NA", instructions)
        if(comments){
          instructions <- paste0(instructions, ' # as Date (with uniform distribution by ', uniqueByType,')')
        }
      }
    }

    # POSIXt:
    # This section initially drafted by copilot, initial review and corrections by RWB
    if(inherits(oneVariable, "POSIXct")){
      # If there are 12 or fewer unique timestamps, sample with original probability
      if(is.na(instructions) & length(unique(oneVariable)) <= 12){

        tz <- attr(oneVariable, "tzone")
        # Format values to full seconds; include timezone in the string for robust parsing
        vals_chr <- format(unique(oneVariable), "%Y-%m-%d %H:%M:%S", usetz = TRUE)

        if(!is.null(tz) && nzchar(tz)){
          instructions <- paste0(
            '`', variableName, '`',
            ' = as.POSIXct(sample(c("',
            paste0(vals_chr, collapse = '", "'),
            '"), ',
            number_of_observations,
            ', replace = TRUE, prob = c(',
            paste0(prop.table(table(oneVariable, useNA = "ifany")), collapse = ', '),
            ')), tz = "', tz, '")'
          )
        } else {
          instructions <- paste0(
            '`', variableName, '`',
            ' = as.POSIXct(sample(c("',
            paste0(vals_chr, collapse = '", "'),
            '"), ',
            number_of_observations,
            ', replace = TRUE, prob = c(',
            paste0(prop.table(table(oneVariable, useNA = "ifany")), collapse = ', '),
            ')))'
          )
        }

        instructions <- gsub("'NA'", "NA", instructions)
        if(comments){
          instructions <- paste0(instructions, ' # as POSIXct (with original probability)')
        }
      }

      # If more than 12 unique timestamps, detect granularity and sample uniformly
      if(is.na(instructions) & length(unique(oneVariable)) > 12){

        # Detect if timestamps are unique by second, minute, hour, day, month, or year
        uniqueByType <- "sec"
        mins   <- format(oneVariable, "%Y-%m-%d %H:%M")
        if(length(unique(mins))   == length(unique(oneVariable))) uniqueByType <- "min"
        hours  <- format(oneVariable, "%Y-%m-%d %H")
        if(length(unique(hours))  == length(unique(oneVariable))) uniqueByType <- "hour"
        days   <- format(oneVariable, "%Y-%m-%d")
        if(length(unique(days))   == length(unique(oneVariable))) uniqueByType <- "day"
        months <- format(oneVariable, "%Y-%m")
        if(length(unique(months)) == length(unique(oneVariable))) uniqueByType <- "month"
        years  <- format(oneVariable, "%Y")
        if(length(unique(years))  == length(unique(oneVariable))) uniqueByType <- "year"

        startDT <- suppressWarnings(min(oneVariable, na.rm = TRUE))
        endDT   <- suppressWarnings(max(oneVariable, na.rm = TRUE))
        tz <- attr(oneVariable, "tzone")
        start_str <- format(startDT, "%Y-%m-%d %H:%M:%S")
        end_str   <- format(endDT,   "%Y-%m-%d %H:%M:%S")

        if(!is.null(tz) && nzchar(tz)){
          instructions <- paste0(
            '`', variableName, '`',
            ' = sample(seq(as.POSIXct("', start_str, '", tz = "', tz, '"), ',
            'as.POSIXct("', end_str, '", tz = "', tz, '"), ',
            'by = "', uniqueByType, '"), ',
            number_of_observations,', replace = TRUE)'
          )
        } else {
          instructions <- paste0(
            '`', variableName, '`',
            ' = sample(seq(as.POSIXct("', start_str, '"), ',
            'as.POSIXct("', end_str, '"), ',
            'by = "', uniqueByType, '"), ',
            number_of_observations,', replace = TRUE)'
          )
        }

        instructions <- gsub("'NA'", "NA", instructions)
        if(comments){
          instructions <- paste0(instructions, ' # as POSIXct (with uniform distribution by ', uniqueByType,')')
        }
      }
    }



    # logicals:
    if(inherits(oneVariable,"logical")) {
      # match proportional distribution of source
      instructions <- paste0('`',variableName,'`',' = sample(c("',paste0(unlist(unique(oneVariable)),collapse = '", "'),'"), ', number_of_observations,', replace = TRUE, prob = c(',paste0(prop.table(table(oneVariable, useNA = 'ifany')), collapse = ', '),'))', collapse = '')
      instructions <- gsub('"NA"', "NA", instructions)
      instructions <- gsub('"FALSE"', "FALSE", instructions)
      instructions <- gsub('"TRUE"', "TRUE", instructions)
      if(comments){
        instructions <- paste0(instructions, ' # as logical')
      }
    }

    # unmatched:
    if(is.na(instructions)) {
      # return vector of NA integers
      # if comments, indicate unmodeled data class
      instructions <- paste0("`",variableName,"`", " = as.integer(NA)")
      if(comments){
        instructions <- paste0(instructions, " # [",variableName,"] of class [",paste0(class(oneVariable), collapse =  "], ["),"] not modeled")
      }
    }

    return(instructions)
  }

  # Loop through the core function to model entire DT and parse output
  batch_variable_modeler <- function(x){
    variable_modeler(oneVariable = ph.data[,x, with = F][[1]], number_of_observations =  number_of_observations, varName = names(ph.data)[x], comments = comments)
  }

  codeList <- lapply(seq_along(ph.data), batch_variable_modeler)

  if(comments) {
    codeListParsed <- c(list("DT <- data.table("),gsub(" #", ", #", codeList[1:(length(codeList)-1)]), gsub(" #",") #",codeList[length(codeList)]))
  } else {
    codeListParsed <- c(list("DT <- data.table("),paste0(codeList[1:(length(codeList)-1)], ","), paste0(codeList[length(codeList)], ")"))
  }

  codeText <- paste(unlist(codeListParsed), collapse =" \n" )

  # issue warning if any variables were not modeled
  if(grepl("] not modeled" ,codeText)) {
    warning("There are one or more variables that could not be modeled. These will be NA columns in the model data. Review comments (run with comments = TRUE) for additional details")
  }

  if(print_code) {
    cat(codeText)
  }

  if(return_code) {
    return(codeListParsed)
  }else{
    DT <- eval(parse(text = paste0(codeText)))
    return(DT)
  }
}
