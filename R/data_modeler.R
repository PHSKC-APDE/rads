#' Generate synthetic data for use in public sharing or testing
#'
#' @description
#' Receives a data table of public health data and returns a synthetic version that is identically structured but uncorrelated. User may request results as a data.table or as code that will generate the data once executed.
#'
#' @param ph.data a data.table or data.frame.
#' @param number_of_observations Character vector of any length or integer greater than 1. Strings will appear in code as a variable, integers as an integer. If requesting output as data, must be an integer.
#' @param comments Logical vector of length 1. Indicate if code should include comments. Comments describe how each column was defined.
#' @param return_code Logical vector of length 1. Indicates if the user wants the function to return a list of code strings used to model the data (TRUE) or a data.table of the synthetic data (FALSE)
#' @param print_code Logical vector of length 1. Indicates if the code generated by the modeler should be printed to console. Note, if you with to copy and paste the code for use in your own work, it is recommended to use this console output.
#'
#' @return Outputs code block to terminal and if (return_code = FALSE) returns a data.table of the synthetic data. If (return_code = TRUE) returns a list of character vectors used to create the code strings. If (comments = TRUE) code will include comments describing the data type of each column.
#'
#' @export
#' @name data_modeler
#' @references \url{CREATE A WIKI FOR THIS}
#'
#' @import data.table rads.data
#'
#' @examples
#' \donttest{
#'   library(data.table)
#'   ph.data <- get_data_birth(cols = c('race4', 'chi_age', 'hra20_name',
#'                                    'sex', 'birth_weight_grams'))
#'
#'   ##Observe that modeled data have the same structure as the original
#'   DT.synthetic.data <- data_modeler(ph.data = ph.data,
#'                                    number_of_observations =  10000,
#'                                    comments = TRUE,
#'                                    return_code = FALSE,
#'                                    print_code = FALSE)
#'   str(ph.data)
#'   str(DT.synthetic.data)
#'
#'
#'   ## Manually convert received code into data
#'   DT.code <- data_modeler(ph.data = ph.data,
#'                                     number_of_observations =  10000,
#'                                     comments = TRUE,
#'                                     return_code = TRUE,
#'                                     print_code = TRUE)
#'   codeText <- paste(unlist(DT.code), collapse =" \n" )
#'   DT.synthetic.data.manual <- eval( parse(text = paste0(codeText)))
#'   str(ph.data)
#'   str(DT.synthetic.data.manual)
#' }
#'

data_modeler <- function(ph.data, number_of_observations, comments = TRUE, return_code = FALSE, print_code = TRUE) {
  ### generates a synthetic data set appropriate for testing functions relying on APDE data structures and where you do not want to use real data
  ### receives description of data set to emulate, number of observations to include, a seed and number of years.
  ### returns a data.table of synthetic data. If dataset is "generic" the returned structure will have idealized chi values and generic indicators

  # Global variables used by data.table declared as NULL to make devtools::check() happy ----
  RH <- DT <- `..x` <- NULL

#TEST DATA
# DT_analytic_ready <- get_data_chars()
# DT_analytic_ready$chi_race_7 <- factor(DT_analytic_ready$chi_race_7, ordered = T)
# DT_analytic_ready$chi_race_7 <- factor(DT_analytic_ready$chi_race_eth8, ordered = F)
#
# ph.data <- DT_analytic_ready
# number_of_observations <- 100
# comments <- TRUE
# return_code <- FALSE
# print_code <- TRUE

  # Validate inputs ----
  if(missing(ph.data)){stop('\n\U1F6D1 ph.data must be provided')}

  if (is.data.frame(ph.data)) {
    setDT(ph.data)
  } else {
    stop(paste0("\n\U1F6D1 ph.data must be a data.table or data.frame."))
  }

  for (arg_name in c("comments", "return_code", "print_code")) {
    arg_value <- get(arg_name)
    if(!is.logical(arg_value)) {
      stop("\n\U1F6D1 The `", arg_name, "` argument must be a logical, i.e., TRUE | FALSE")
    }
    if(length(arg_value) != 1) {
      stop("\n\U1F6D1 The `", arg_name, "` argument must be of length 1")
    }
  }

  if(inherits(number_of_observations, "character") & return_code == FALSE) {
    number_of_observations <- as.integer(number_of_observations)
    if(is.na(number_of_observations)) {
      stop("user has requested data, but 'number_of_observations' could not be coerced to an integer. 'number_of_observations' must be an integer.")
    }
    if(number_of_observations <= 0) {
      stop("number_of_observations must be an integer greater than 0")
    }
  }

  # Core function: convert provided data into an executable string that generates similar looking data ----
  variable_modeler <- function(oneVariable, number_of_observations, varName = NA, comments = TRUE) {
    if(any(class(oneVariable) %in% "data.table")) {
      if(ncol(oneVariable) == 1) {
        message(class(oneVariable))
        oneVariable <- oneVariable[,1][[1]]
        #message(class(oneVariable))
        #message("caught DT")
      } else {
        stop("more than 1 column passed. Only pass a vector or one column")
      }
    }

    instructions <- NA

    if(is.na(varName)) {
      variableName <- sub(".*\\$.*?", "\\1", deparse(substitute(oneVariable)))
    } else {
      variableName <- varName
    }

    #oneVariableClass <- class(oneVariable)


    #factors:
    if(inherits(oneVariable, "factor")) {
      #generic factor replication. For any factor, mirror the probability of its levels. If ordered, reproduce the orders.
      if(is.na(instructions)) {
        orderTF <- is.ordered(oneVariable)
        detectedLevels <- levels(oneVariable)
        instructions <- paste0('`',variableName,'`',' = factor(sample(c("',paste0(unlist(unique(oneVariable)),collapse = '", "'),'"), ', number_of_observations,', replace = TRUE, prob = c(',paste0(prop.table(table(oneVariable, useNA = 'ifany')), collapse = ', '),')), levels = c("',paste0(detectedLevels, collapse = '", "'),'"), ordered = ', orderTF,')', collapse = '')
        instructions <- gsub("'NA'", 'NA', instructions)
        if(comments) {
          instructions <- paste0(instructions, ' # as factor')
        }
      }
    }

    #integers:
    if(inherits(oneVariable,"integer")) {
      # categorical integers:
      # assumed to be if there are 61 (number of HRAs) or fewer unique items on a vector with 61 or more rows
      # OR
      # if all are unique
      # these are reapplied with probability matching the proportion of each variable
      if(is.na(instructions) &
         ((length(unique(oneVariable)) <= 61 & length(oneVariable) >= 61) | (length(unique(oneVariable)) == length(oneVariable)))) {
        instructions <- paste0("`",variableName,"`"," = as.integer(sample(c('",paste0(unlist(unique(oneVariable)),collapse = "', '"),"'), ", number_of_observations,", replace = TRUE, prob = c(",paste0(prop.table(table(oneVariable, useNA = 'ifany')), collapse = ", "),")))", collapse = "")
        instructions <- gsub("'NA'", "NA", instructions)
        if(comments){
          instructions <- paste0(instructions, " # as categorical integer (non factor)")
        }
      }
      #continuous integer:
      # assumed to be if there are more than 61 (number of HRAs) items on a vector with 61 or more rows
      # AND
      # all values are not unique
      # these are reapplied in a defined distribution between the minimum and maximum of the range
      if(is.na(instructions) &
         ((length(unique(oneVariable)) > 61) & (length(unique(oneVariable)) != length(oneVariable)))) {
        #uniform distribution
        instructions <- paste0("`",variableName,"`", " = as.integer(runif(", number_of_observations,", ", min(oneVariable, na.rm = TRUE), ", ", max(oneVariable, na.rm = TRUE),"))")
        if(comments) {
          instructions <- paste0(instructions, " # as continuous integer with uniform distribution")
        }
      }
    }

    #doubles:
    if(inherits(oneVariable, "double")) {
      #continuous double:
      # assumed to be if there are more than 61 (number of HRAs) items on a vector with 61 or more rows
      # AND
      # all values are not unique
      # these are reapplied in a defined distribution between the minimum and maximum of the range
      if(is.na(instructions) &
         ((length(unique(oneVariable)) > 61) & (length(unique(oneVariable)) != length(oneVariable)))) {
        #used to recreate the number of decimal places accurately
        count_decimal_places <- function(x) {
          if (!is.numeric(x)) return(NA)
          sapply(x, function(num) {
            if (is.na(num)) return(NA)
            str_num <- as.character(num)
            if (grepl("\\.", str_num)) {
              return(nchar(strsplit(str_num, "\\.")[[1]][2]))
            } else {
              return(0)
            }
          })
        }
        oneVariable[,RH := count_decimal_places(oneVariable[[1]])]
        numberOfDecimals <- max(oneVariable$RH, na.rm = T)
        #uniform distribution
        instructions <- paste0("`",variableName,"`", " = as.double(round(runif(", number_of_observations,", ", min(oneVariable, na.rm = TRUE), ", ", max(oneVariable, na.rm = TRUE),"),", numberOfDecimals , "))")
        if(comments) {
          instructions <- paste0(instructions, " # as continuous double with uniform distribution")
        }
      }
    }

    #characters:
    if(inherits(oneVariable, "character")){
      #categorical characters:
      # assumed if there are 61 (number of HRAs) or fewer unique items on a vector with 61 or more rows
      # these are reapplied with probability matching the proportion of each variable
      if(is.na(instructions) & (length(unique(oneVariable)) <= 61 & length(oneVariable) > 61)){
        instructions <- paste0('`',variableName,'`',' = sample(c("',paste0(unlist(unique(oneVariable)),collapse = '", "'),'"), ', number_of_observations,', replace = TRUE, prob = c(',paste0(prop.table(table(oneVariable, useNA = 'ifany')), collapse = ', '),'))', collapse = '')
        instructions <- gsub("'NA'", "NA", instructions)
        if(comments){
          instructions <- paste0(instructions, ' # as categorical character (non factor)')
        }
      }
      # #miscellaneous characters (free text):
      # # assumed if there are more than 61 observations, and 90% or more are unique
      # # replaced with "lorem ipsum" of length similar to source
      # if(is.na(instructions) &
      #    (length(unique(oneVariable)) >= (length(oneVariable) *.90))) {
      #   loremipsum <- "Lorem ipsum dolor sit amet consectetur adipiscing elit. Pretium tellus duis convallis tempus leo eu aenean. Iaculis massa nisl malesuada lacinia integer nunc posuere. Conubia nostra inceptos himenaeos orci varius natoque penatibus. Nulla molestie mattis scelerisque maximus eget fermentum odio."
      #   minimumLength <- min(nchar(oneVariable))
      #   maximumLength <- max(nchar(oneVariable))
      #
      #
      #   minimumLength <- 10
      #   maximumLength <- 30
      #   number_of_observations <- 100
      #   maxes <- sample(1:maximumLength, number_of_observations, replace = TRUE)
      #
      #
      #   LIsplit <- paste0(strsplit(loremipsum, split = "")[[1]][1:maximumLength], collapse = "")
      #   LIsplit <- strsplit(paste0(strsplit(loremipsum, split = "")[[1]][1:maximumLength], collapse = ""), split = " ")[[1]]
      #   LIsplitDT <- data.table(LIsplit)
      #
      #
      #   rep(LIsplit, number_of_observations, )
      #   instructions <- paste0('`',variableName,'`',' = sample(c("',paste0(unlist(unique(oneVariable)),collapse = '", "'),'"), ', number_of_observations,', replace = TRUE, prob = c(',paste0(prop.table(table(oneVariable, useNA = 'ifany')), collapse = ', '),'))', collapse = '')
      #   instructions <- gsub("'NA'", "NA", instructions)
      #   if(comments){
      #     instructions <- paste0(instructions, ' # as categorical character (non factor)')
      #   }
      # }
      #date-like characters:
      # not a date or posix
      # but has date features (/, -, or a length of 6 or 8
      # if(is.na(instructions) &
      #    !inherits(oneVariable, "Date") &
      #    !inherits(oneVariable, "POSIXct") &
      #    !inherits(oneVariable, "POSIXt") &
      #    (length(unique(oneVariable)) >= 61 & length(oneVariable) > 61) &
      #    (all(grepl("/", onevariable)) | all(grepl("-", onevariable)) | (all(nchar(oneVariable) == 6) | all(nchar(oneVariable) == 8)))) {
      #   dateLength <- nchar(oneVariable[1])
      #   #identify format
      #   # short numb: ######
      #   # long numb: ########
      #   # dash short numb:
      #
      #   instructions <- paste0('`',variableName,'`',' = sample(c("',paste0(unlist(unique(oneVariable)),collapse = '", "'),'"), ', number_of_observations,', replace = TRUE, prob = c(',paste0(prop.table(table(oneVariable, useNA = 'ifany')), collapse = ', '),'))', collapse = '')
      #   instructions <- gsub("'NA'", "NA", instructions)
      #   if(comments){
      #
      #     instructions <- paste0(instructions, ' # as a ch')
      #   }
      # }
    }

    #dates:


    #POSIXt:


    #logicals:


    #unmatched:
    if(is.na(instructions)) {
      instructions <- paste0("`",variableName,"`", " = as.integer(NA)")
      if(comments){
        instructions <- paste0(instructions, " # [",variableName,"], of class [",paste0(class(x), collapse =  "]; ["),"] not modeled")
      }
    }

    return(instructions)
  }

  # Loop through the core function to model entire DT and parse output ----
  batch_variable_modeler <- function(x) {
    variable_modeler(oneVariable = ph.data[,x,with = FALSE][[1]], number_of_observations =  number_of_observations, varName = names(ph.data)[x], comments = comments)
  }

  codeList <- lapply(seq_along(ph.data), batch_variable_modeler)


  if(comments) {
    codeListParsed <- c(list("DT <- data.table("),gsub(" #", ", #", codeList[1:(length(codeList)-1)]), gsub(" #",") #",codeList[length(codeList)]))
  } else {
    codeListParsed <- c(list("DT <- data.table("),paste0(codeList[1:(length(codeList)-1)], ","), paste0(codeList[length(codeList)], ")"))
  }

  codeText <- paste(unlist(codeListParsed), collapse =" \n" )

  #issue warning if any variables were not modelled
  if(grepl("] not modeled" ,codeText)) {
    warning("There are one or more variables that could not be modeled. These will be NA columns in the model data. Review comments (run with comments = TRUE) for additional details")
  }

  if(print_code) {
    cat(codeText)
  }

  if(return_code) {
    return(codeListParsed)
  }else{
    eval(parse(text = paste0(codeText)))
    return(DT)
  }
}

