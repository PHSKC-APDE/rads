% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utilities.R
\name{tsql_convert_types}
\alias{tsql_convert_types}
\title{Converts R data types to match TSQL field types using lossless conversion}
\usage{
tsql_convert_types(
  ph.data = NULL,
  field_types = NULL,
  validate_before = TRUE,
  validate_after = TRUE,
  verbose = TRUE,
  return_log = FALSE
)
}
\arguments{
\item{ph.data}{The name of a single data.table/data.frame to be converted.}

\item{field_types}{A named character vector with the desired TSQL datatypes
for your conversion. For example, \code{c(col1 = 'int', col2 = 'float', col3 = 'date')}. Note that the names in \code{field_types} must be the
same as the names in \code{ph.data}. This is often read into memory from a
*.yaml file, but can also be manually created.}

\item{validate_before}{Logical. Should \code{\link[=tsql_validate_field_types]{tsql_validate_field_types()}} be
run before attempting conversion? If \code{TRUE} and validation passes, no
conversion will be attempted. Default is \code{TRUE}.}

\item{validate_after}{Logical. Should \code{\link[=tsql_validate_field_types]{tsql_validate_field_types()}} be
run after conversion to confirm success? Default is \code{TRUE}.}

\item{verbose}{Logical. Should detailed conversion messages be displayed?
Default is \code{TRUE}.}

\item{return_log}{Logical. Should conversion log be returned along with
converted data? If \code{TRUE}, returns a list with 'data' and
'conversion_log' elements. Default is \code{FALSE}.}
}
\value{
If \code{return_log = FALSE}, returns a data.table whose column
names have been converted to lowercase. If \code{return_log = TRUE},
returns a list with \code{data} (the converted data.table, also with
lowercase names) and \code{conversion_log} (a data.table of results).
}
\description{
\code{tsql_convert_types} attempts to safely convert columns in a
data.table/data.frame to match specified TSQL field types using the
\code{\link[=lossless_convert]{lossless_convert()}} function. The function will only perform conversions
that do not introduce new missing values or lose information. This is
particularly useful when preparing data for upload to Microsoft SQL Server
where R data types don't perfectly align with expected TSQL types (e.g.,
character columns that contain numeric values but need to be integers).
}
\details{
This function uses \code{\link[=lossless_convert]{lossless_convert()}} to safely attempt type
conversions. Conversions that would introduce new \code{NA} values or lose
information will not be performed, and the original column will be retained.

The function maps TSQL types to appropriate R classes as follows:
\itemize{
\item \code{tinyint}, \code{smallint}, \code{int}, \code{bit} → \code{integer}
\item \code{bigint}, \code{decimal}, \code{numeric}, \code{float}, \code{real}, \code{money}, \code{smallmoney} → \code{numeric}
\item \code{char}, \code{varchar}, \code{text}, \code{nchar}, \code{nvarchar}, \code{ntext} → \code{character}
\item \code{date} → \code{Date}
\item \code{datetime}, \code{datetime2}, \code{smalldatetime}, \code{datetimeoffset} → \code{POSIXct}
\item \code{binary}, \code{varbinary} → \code{raw}
}

Note: \code{bigint} is mapped to \code{numeric} rather than \code{integer}
because R integers can't handle the full range of TSQL \code{bigint} values.
}
\examples{
\donttest{
# Create example data with type mismatches
 library(data.table)
 mydt <- data.table(apgar_10 = c("8", "9", "7", "10"), #  should be int
                    birth_weight = c("3500", "2800", "4200", "3100"), # should be int
                    sex = c("M", "F", "M", "F")) # already character, matches char(1)

 myfieldtypes <- c(apgar_10 = 'int',
                   birth_weight = 'int',
                   sex = 'char(1)')

 # Basic conversion
 converted_data <- tsql_convert_types(ph.data = mydt, field_types = myfieldtypes)

 # Conversion with detailed log
 result <- tsql_convert_types(ph.data = mydt,
                              field_types = myfieldtypes,
                              return_log = TRUE)
 converted_data <- result$data
 conversion_log <- result$conversion_log
}

}
