<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Introduction</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h2>Introduction</h2>

<p>The comparison of crude health indicator rates across populations is often confounded by different age structures. For example, in 2019 the mean age of Hispanic King County residents was ~12.5 years younger than that of white residents (27.5 vs 40). Given this age discrepancy, we should expect higher mortality rates among white residents. However, you might be thinking, <em>“Is there a way to compare Hispanic and white mortality rates while fully accounting for their different age structures? I.e., is there a way to standardize or adjust for age?”</em> </p>

<p>While you can use Poisson regression or other advanced statistical techniques to calculate age adjusted rates, for simplicity and broader comparison with the work of others, it is often beneficial to adjust your data using a standard reference population. This process is called <strong><em>age standardization</em></strong>. Age standardization answers the question, <em>“What rates would I observe if my data had the same age structure as a different population?”</em></p>

<p>There are 35 reference populations baked into <code>rads</code> (via it&#39;s dependency on <a href="https://github.com/PHSKC-APDE/rads.data"><code>rads.data</code></a>). Their names are visible when you type <code>list_ref_pop()</code>. Here are the first five as an example:</p>

<pre><code class="r">list_ref_pop()[1:5]
</code></pre>

<pre><code>## [1] &quot;2000 U.S. Std Population (18 age groups - Census P25-1130)&quot;    
## [2] &quot;2000 U.S. Std Population (19 age groups - Census P25-1130)&quot;    
## [3] &quot;2000 U.S. Std Population (single ages to 84 - Census P25-1130)&quot;
## [4] &quot;2000 U.S. Std Population (single ages to 99 - Census P25-1130)&quot;
## [5] &quot;1940 U.S. Std Million (18 age groups)&quot;
</code></pre>

<p>The first one is the default reference population used by APDE. Taking a peek behind the curtain shows that each reference standard is a simple table of age ranges with their corresponding populations. </p>

<pre><code class="r">get_ref_pop(&quot;2000 U.S. Std Population (18 age groups - Census P25-1130)&quot;)[, 1:4]
</code></pre>

<pre><code>##          agecat age_start age_end      pop
##  1:   0-4 years         0       4 18986520
##  2:   5-9 years         5       9 19919840
##  3: 10-14 years        10      14 20056779
##  4: 15-19 years        15      19 19819518
##  5: 20-24 years        20      24 18257225
##  6: 25-29 years        25      29 17722067
##  7: 30-34 years        30      34 19511370
##  8: 35-39 years        35      39 22179956
##  9: 40-44 years        40      44 22479229
## 10: 45-49 years        45      49 19805793
## 11: 50-54 years        50      54 17224359
## 12: 55-59 years        55      59 13307234
## 13: 60-64 years        60      64 10654272
## 14: 65-69 years        65      69  9409940
## 15: 70-74 years        70      74  8725574
## 16: 75-79 years        75      79  7414559
## 17: 80-84 years        80      84  4900234
## 18:   85+ years        85     120  4259173
</code></pre>

<p>The <code>age_standardize()</code> function provides a simple way to use reference populations to calculate age standardized rates. This vignette will provide some examples of how to use <code>age_standardize()</code> and how to understand its output. To get the most out of this vignette, we recommend that you type each and every bit of code into R. Doing so will almost definitely help you learn the syntax much faster than just reading the vignette or copying and pasting the code.</p>

<h2><code>age_standardize()</code> arguments</h2>

<p>Arguments are the values that we send to a function when it is called. The standard arguments for <code>age_standardize()</code> are:</p>

<p>1) <code>my.dt</code> &lt;- the name of the data.table/data.frame with the data that you want to age standardize. <strong>Note:</strong> <em>my.dt must contain a numeric column named &#39;age&#39;. The sole exception is if it already has a standard population merged onto the dataset, in which case it must contain a numeric column named &#39;stdpop&#39;.</em></p>

<p>2) <code>ref.popname</code> &lt;- a character vector whose only valid options are &ldquo;none&rdquo; (used when my.dt has a &#39;stdpop&#39; column) or one of the reference standarards contained in <code>list_ref_pop()</code></p>

<p>3) <code>collapse</code> &lt;- a logical vector (T|F), determines whether or not to to collapse the &#39;age&#39; column in my.dt to match those in ref.popname. If your data is already collapsed / aggregated into the same age bins as your reference population, and if that variable is named &ldquo;agecat&rdquo;, then you can set collapse to F. The default is T</p>

<p>4) <code>my.count</code> &lt;- a character vector, identifies the column name for the <strong>aggregated</strong> count data in my.dt. The default is &ldquo;count&rdquo;</p>

<p>5) <code>my.pop</code> &lt;- a character vector, identifies the column name for the population number corresponding to the count. The default is &ldquo;pop&rdquo;</p>

<p>6) <code>per</code> &lt;- an integer, used as multiplier for all rates and CI, e.g., when per = 1000, the rates are per 1000 persons. The default is 100,000</p>

<p>7) <code>conf.level</code> &lt;- a numeric value between 0.00 &amp; 0.99, designates the confidence level (i.e., 1 - alpha) to be used in the calculations. The default is 0.95 </p>

<p>8) <code>group_by</code> &lt;- a character, specifies the variable(s) by which to stratify the rate results (if any). The default is NULL (i.e., no stratification)</p>

<h2>Preparing your datset</h2>

<p>Your dataset must have the following three columns &hellip; </p>

<p>1) &#39;age&#39; or &#39;agecat&#39;: &#39;age&#39; in single years (if collapse = T) or &#39;agecat&#39; with the same age bins as your selected reference population (if collapse = F).</p>

<p>2) a count for the event (e.g., disease) for which you want to find an age standardized rate.</p>

<p>3) the population corresponding to the age or agecat in your original data</p>

<hr/>

<h2>Example #1: The Basics</h2>

<p><strong>Create synthetic line level data for a cohort 51 to 60 years of age with a binary indicator for disease status</strong></p>

<pre><code class="r">library(data.table)
set.seed(98121)

temp1 &lt;- data.table(
  age = rep(51:60, 100), 
  disease = sample(0:1, 1000, replace = T), 
  pop = rep(c(seq(1000, 910, -10)), 100))

temp1[]
</code></pre>

<pre><code>##       age disease  pop
##    1:  51       0 1000
##    2:  52       1  990
##    3:  53       0  980
##    4:  54       1  970
##    5:  55       1  960
##   ---                 
##  996:  56       1  950
##  997:  57       1  940
##  998:  58       1  930
##  999:  59       1  920
## 1000:  60       0  910
</code></pre>

<p><strong>Run age_standardize with APDE&#39;s default population</strong></p>

<pre><code class="r">age_standardize(my.dt = temp1,
                ref.popname = &quot;2000 U.S. Std Population (18 age groups - Census P25-1130)&quot;, 
                collapse = T,
                my.count = &quot;disease&quot;, 
                my.pop = &quot;pop&quot;, 
                per = 1000, 
                conf.level = 0.95)[]
</code></pre>

<pre><code>##    count    pop crude.rate crude.lci crude.uci adj.rate adj.lci adj.uci
## 1:   511 955000       0.54      0.49      0.58     0.52    0.47    0.58
##                                                 reference_pop
## 1: 2000 U.S. Std Population (18 age groups - Census P25-1130)
</code></pre>

<p><em>Does anything seem fishy? Think for a moment &hellip;</em> </p>

<ul>
<li><p><strong>count</strong> is the number of events that occured (i.e., the numerator)</p></li>
<li><p><strong>pop</strong> is the population corresponding to the count (i.e., the denominator)</p></li>
<li><p><strong>crude.rate, crude.lci, &amp; crude.uci</strong> are the crude (i.e., observed) rate and CI</p></li>
<li><p><strong>adj.rate, adj.lci, &amp; adj.uci</strong> are the age standardized rate and CI</p></li>
</ul>

<p><em>Did you find the problem?</em></p>

<p>The problem is that the population is too big. Eyeballing the output when we created the dataset above, we see that the total population for those 51 to 60 would have to be less than 10,000. In this case it is almost 1 million! In the description of the arguments above, it specifies that we need to use aggregated count data. Now you see why. Ignoring that detail caused us to inflate the population (and therefore deflate the rate and CI) 1000x.</p>

<p><strong>Aggregate (collapse) the line level data</strong></p>

<pre><code class="r">temp1 &lt;- temp1[, .(disease = sum(disease)), by = c(&quot;age&quot;, &quot;pop&quot;)]
temp1[]
</code></pre>

<pre><code>##     age  pop disease
##  1:  51 1000      49
##  2:  52  990      46
##  3:  53  980      50
##  4:  54  970      47
##  5:  55  960      60
##  6:  56  950      50
##  7:  57  940      61
##  8:  58  930      50
##  9:  59  920      52
## 10:  60  910      46
</code></pre>

<p><strong>Run age_standardize again &lt;&lt; this time with aggregated disease events</strong></p>

<pre><code class="r">ex1.1 &lt;- age_standardize(my.dt = temp1,
                      ref.popname = &quot;2000 U.S. Std Population (18 age groups - Census P25-1130)&quot;, 
                      collapse = T,
                      my.count = &quot;disease&quot;, 
                      my.pop = &quot;pop&quot;, 
                      per = 1000, 
                      conf.level = 0.95)
ex1.1[]
</code></pre>

<pre><code>##    count  pop crude.rate crude.lci crude.uci adj.rate adj.lci adj.uci
## 1:   511 9550      53.51     48.97     58.35    52.22   47.11   57.92
##                                                 reference_pop
## 1: 2000 U.S. Std Population (18 age groups - Census P25-1130)
</code></pre>

<p>Now that count, pop, and rates seem reasonable, let&#39;s see what happens if we change the reference population. We&#39;ll arbitrarily set the references population to the 35th in the list provided by <code>list_ref_pop()</code> (i.e., &#39;World (WHO 2000-2025) Std Million (single ages to 99)&#39;). </p>

<pre><code class="r">ex1.2 &lt;- age_standardize(my.dt = temp1,
                      ref.popname = list_ref_pop()[35], 
                      collapse = T,
                      my.count = &quot;disease&quot;, 
                      my.pop = &quot;pop&quot;, 
                      per = 1000, 
                      conf.level = 0.95)
ex1.2[]
</code></pre>

<pre><code>##    count  pop crude.rate crude.lci crude.uci adj.rate adj.lci adj.uci
## 1:   511 9550      53.51     48.97     58.35    53.34   48.81    58.2
##                                            reference_pop
## 1: World (WHO 2000-2025) Std Million (single ages to 99)
</code></pre>

<p>As we&#39;d expect, the crude rates are identical since the reference population is irrelevant for those calculations (53.51 vs 53.51). However, the age-standardized rates changed from 52.22 to 53.34. Remember, if you want to compare your age-adjusted rates to those published by other health jurisdictions, it&#39;s important that you use the same reference population.</p>

<hr/>

<h2>Example #2: Stratifcation</h2>

<p><strong>Let&#39;s create a new dataset with disease counts aggregated by age (46 to 64) and gender (F|M)</strong></p>

<pre><code class="r">set.seed(98121)
temp2 &lt;- data.table(
  gender = c(rep(&quot;F&quot;, 20), rep(&quot;M&quot;, 20)), 
  age = rep(46:65, 2),
  disease = c(sample(25:46, 20, replace = T), sample(25:35, 20, replace = T)), 
  pop = c(sample(2500:3500, 20, replace = T), sample(2200:3300, 20, replace = T)))

head(temp2)
</code></pre>

<pre><code>##    gender age disease  pop
## 1:      F  46      32 3134
## 2:      F  47      36 2930
## 3:      F  48      29 3289
## 4:      F  49      27 3198
## 5:      F  50      27 3480
## 6:      F  51      33 2679
</code></pre>

<p><strong>Let&#39;s examine the overall rates</strong></p>

<pre><code class="r">ex2.1 &lt;- age_standardize(my.dt = temp2,
                       collapse = T,
                       my.count = &quot;disease&quot;, 
                       my.pop = &quot;pop&quot;, 
                       per = 1000, 
                       conf.level = 0.95)

ex2.1[]
</code></pre>

<pre><code>##    count    pop crude.rate crude.lci crude.uci adj.rate adj.lci adj.uci
## 1:  1333 115448      11.55     10.93     12.18    11.55   10.87   12.27
##                                                 reference_pop
## 1: 2000 U.S. Std Population (18 age groups - Census P25-1130)
</code></pre>

<p>In this case, the crude rate and age standardized rate are the same. This doesn&#39;t mean there is a mistake. Notice that the confidence intervals differ &ndash; as would be expected. </p>

<p>Also notice that we didn&#39;t include the <code>ref.popname</code> argument. When it is not specified, <code>age_standardize()</code> uses the default which is <code>list_ref_pop()[1]</code> (i.e, 2000 U.S. Std Population (18 age groups - Census P25-1130)).</p>

<p><strong>Now let&#39;s run the same analysis, but stratified by gender</strong></p>

<pre><code class="r">ex2.2 &lt;- age_standardize(my.dt = temp2,
                       collapse = T,
                       my.count = &quot;disease&quot;, 
                       my.pop = &quot;pop&quot;, 
                       per = 1000, 
                       conf.level = 0.95, 
                       group_by = &quot;gender&quot;)

ex2.2[]
</code></pre>

<pre><code>##    gender count   pop crude.rate crude.lci crude.uci adj.rate adj.lci adj.uci
## 1:      F   731 60827      12.02     11.16     12.92    11.88   10.95   12.90
## 2:      M   602 54621      11.02     10.16     11.94    11.21   10.25   12.26
##                                                 reference_pop
## 1: 2000 U.S. Std Population (18 age groups - Census P25-1130)
## 2: 2000 U.S. Std Population (18 age groups - Census P25-1130)
</code></pre>

<p>Here we see that the crude and age standardized rates are higher among females when compared to males. </p>

<hr/>

<h2>Example #3: Using your own standard population</h2>

<p><strong>Create a reference population for the gendered dataset above</strong></p>

<p>To keep things simple, we will create a reference population based on single ages rather than age bins. As specified in the arguments description above, we will name the standard population column &#39;stdpop&#39;.</p>

<pre><code class="r">set.seed(98121)
new.standard &lt;- data.table(
  gender = c(rep(&quot;M&quot;, 20), rep(&quot;F&quot;, 20)), 
  age = rep(46:65, 2),
  stdpop = c(sample(7800:16000, 20, replace = T), sample(10000:20000, 20, replace = T)))

head(new.standard)
</code></pre>

<pre><code>##    gender age stdpop
## 1:      M  46  10160
## 2:      M  47   8515
## 3:      M  48   9204
## 4:      M  49   7827
## 5:      M  50   9756
## 6:      M  51   9178
</code></pre>

<p><strong>Merge the standard population onto the data</strong></p>

<pre><code class="r">temp3 &lt;- merge(temp2, new.standard, by = c(&quot;age&quot;, &quot;gender&quot;), all = T)

head(temp3)
</code></pre>

<pre><code>##    age gender disease  pop stdpop
## 1:  46      F      32 3134  14506
## 2:  46      M      26 3055  10160
## 3:  47      F      36 2930  18955
## 4:  47      M      35 2954   8515
## 5:  48      F      29 3289  17813
## 6:  48      M      35 2268   9204
</code></pre>

<p><strong>Calculate the rates when <code>ref.pop = &quot;none&quot;</code></strong></p>

<p>Note that I need to specify <code>collapse = F</code> because the function expects data to be pre-aggregated for the custom reference population contained in <code>stdpop</code>.</p>

<pre><code class="r">ex3.1 &lt;- age_standardize(my.dt = temp3,
                       ref.popname = &quot;none&quot;,
                       collapse = F,
                       my.count = &quot;disease&quot;, 
                       my.pop = &quot;pop&quot;, 
                       per = 1000, 
                       conf.level = 0.95, 
                       group_by = &quot;gender&quot;)

ex3.1[]
</code></pre>

<pre><code>##    gender count   pop crude.rate crude.lci crude.uci adj.rate adj.lci adj.uci
## 1:      F   731 60827      12.02     11.16     12.92    12.02   11.15   12.95
## 2:      M   602 54621      11.02     10.16     11.94    11.15   10.25   12.12
##               reference_pop
## 1: stdpop column in `temp3`
## 2: stdpop column in `temp3`
</code></pre>

<hr/>

<h2>Example #4: When to specify <code>collapse = F</code></h2>

<p>In example #3 above, we specified <code>collapse = F</code> because <code>age_standardardize()</code> expects the data to be pre-aggregated when you provide a <code>stdpop</code> column. The other time when you will want to set <code>collapse = F</code> is if you have data that has already been collapsed down to the reference population&#39;s age bins along with the proper labels in a column called <code>agecat</code>. <strong>This is uncommon.</strong> It isn&#39;t worth your time and energy to manually collapse the data &ndash; so don&#39;t do it! This functionality is here just in case you receive data that has already been structured this way.</p>

<p><strong>Let&#39;s recreate the dataset used in example 2 above</strong></p>

<pre><code class="r">set.seed(98121)
temp4 &lt;- data.table(
  gender = c(rep(&quot;M&quot;, 20), rep(&quot;F&quot;, 20)), 
  age = rep(46:65, 2),
  disease = c(sample(25:46, 20, replace = T), sample(25:35, 20, replace = T)), 
  pop = c(sample(2500:3500, 20, replace = T), sample(2200:3300, 20, replace = T)))

head(temp4)
</code></pre>

<pre><code>##    gender age disease  pop
## 1:      M  46      32 3134
## 2:      M  47      36 2930
## 3:      M  48      29 3289
## 4:      M  49      27 3198
## 5:      M  50      27 3480
## 6:      M  51      33 2679
</code></pre>

<p><strong>Collapse the data down to the same age bins as those used in the APDE standard reference population</strong></p>

<pre><code class="r">temp4[age %in% 45:49, agecat := &quot;45-49 years&quot;]
temp4[age %in% 50:54, agecat := &quot;50-54 years&quot;]
temp4[age %in% 55:59, agecat := &quot;55-59 years&quot;]
temp4[age %in% 60:64, agecat := &quot;60-64 years&quot;]
temp4[age %in% 65:69, agecat := &quot;65-69 years&quot;]
temp4 &lt;- temp4[, .(pop = sum(pop), disease = sum(disease)), by = c(&quot;agecat&quot;, &quot;gender&quot;)]

temp4[]
</code></pre>

<pre><code>##          agecat gender   pop disease
##  1: 45-49 years      M 12551     124
##  2: 50-54 years      M 15192     169
##  3: 55-59 years      M 15466     198
##  4: 60-64 years      M 14425     194
##  5: 65-69 years      M  3193      46
##  6: 45-49 years      F 11302     130
##  7: 50-54 years      F 13392     149
##  8: 55-59 years      F 12631     159
##  9: 60-64 years      F 14498     133
## 10: 65-69 years      F  2798      31
</code></pre>

<p><strong>Now you are able to run age_standardize with <code>collapse = F</code></strong></p>

<pre><code class="r">ex4.1 &lt;- age_standardize(my.dt = temp4,
                       collapse = F,
                       my.count = &quot;disease&quot;, 
                       my.pop = &quot;pop&quot;, 
                       per = 1000, 
                       conf.level = 0.95, 
                       group_by = &quot;gender&quot;)

ex4.1[]
</code></pre>

<pre><code>##    gender count   pop crude.rate crude.lci crude.uci adj.rate adj.lci adj.uci
## 1:      M   731 60827      12.02     11.16     12.92    11.88   10.95   12.90
## 2:      F   602 54621      11.02     10.16     11.94    11.21   10.25   12.26
##                                                 reference_pop
## 1: 2000 U.S. Std Population (18 age groups - Census P25-1130)
## 2: 2000 U.S. Std Population (18 age groups - Census P25-1130)
</code></pre>

<p>Note the results in ex4.1 are exactly the same as those in ex2.2. This makes sense since <code>age_standardize()</code> collapsed the data in a similar (but more efficient manner) when creating ex2.2.</p>

<hr/>

<h2>Example #5: Real world analysis</h2>

<p>You&#39;re staffing data requests today and receive the following message: &ldquo;<em>Hi! For a class, I&#39;d like to get the 2019 teen (13 to 19) birth rate for King County and WA State as a whole. Since the age distribution in the county may differ from the rest of the state, it would be appreciated if you could provide crude and age-standardized rates. If you could standardize to &quot;World (WHO 2000-2025) Std Million (single ages to 84)&rdquo;, that would be great! Thank you, S. Capstone</em>&ldquo; </p>

<p>You quickly pull up <a href="https://www.doh.wa.gov/ForPublicHealthandHealthcareProviders/PublicHealthSystemResourcesandServices/CommunityHealthAssessmentandImprovement/CHAT">CHAT</a> only to find that this specific indicator doesn&#39;t exist. You remember that <a href="https://kingcounty.gov/chi/">CHI</a> has an adolescent birth rate indicator, but are downcast when you find that it applies to those 15 to 17. In desperation, you resign yourself to using <code>rads</code>. </p>

<p><strong>Get birth counts for 13 to 19 year olds in 2019</strong></p>

<pre><code class="r">  kcbirth &lt;- get_data_birth(cols = c(&quot;chi_age&quot;, &quot;chi_year&quot;), year = 2019, kingco = T)
  wabirth &lt;- get_data_birth(cols = c(&quot;chi_age&quot;, &quot;chi_year&quot;), year = 2019, kingco = F)

  births &lt;- rbind(kcbirth[, geo := &quot;King County&quot;], wabirth[, geo := &quot;WA State&quot;])
  births &lt;- births[chi_age %in% 13:19]

  # collapse / aggregate
  births &lt;- births[, .(births = .N), by = c(&quot;chi_age&quot;, &quot;geo&quot;)] 
  setorder(births, geo, chi_age)
  setnames(births, &quot;chi_age&quot;, &quot;age&quot;)
  births[]
</code></pre>

<pre><code>##     age         geo births
##  1:  13 King County      1
##  2:  14 King County      4
##  3:  15 King County     10
##  4:  16 King County     23
##  5:  17 King County     44
##  6:  18 King County    111
##  7:  19 King County    227
##  8:  13    WA State      6
##  9:  14    WA State     16
## 10:  15    WA State     69
## 11:  16    WA State    190
## 12:  17    WA State    348
## 13:  18    WA State    751
## 14:  19    WA State   1481
</code></pre>

<p><strong>Get the female populations corresponding to the birth counts</strong></p>

<pre><code class="r">  kcpop &lt;- get_population(kingco = T, years = 2019, ages = 13:19, 
                          genders = &quot;Female&quot;, group_by = &quot;ages&quot;)
  kcpop &lt;- kcpop[, .(age, geo = geo_id, pop)] 

  wapop &lt;- get_population(kingco = F, years = 2019, ages = 13:19, 
                          genders = &quot;Female&quot;, group_by = &quot;ages&quot;, geo_type = &quot;zip&quot;)
  wapop &lt;- wapop[, .(pop = sum(pop), geo = &quot;WA State&quot;), by = &quot;age&quot;]

  pop &lt;- rbind(kcpop, wapop)
  pop[]
</code></pre>

<pre><code>##     age         geo   pop
##  1:  13 King County 12180
##  2:  14 King County 12077
##  3:  15 King County 11943
##  4:  16 King County 12292
##  5:  17 King County 12416
##  6:  18 King County 12776
##  7:  19 King County 13166
##  8:  13    WA State 46590
##  9:  14    WA State 46446
## 10:  15    WA State 45120
## 11:  16    WA State 44849
## 12:  17    WA State 44562
## 13:  18    WA State 45809
## 14:  19    WA State 46540
</code></pre>

<p><strong>Merge population onto to birth counts</strong></p>

<pre><code class="r">  temp5 &lt;- merge(births, pop, by = c(&quot;age&quot;, &quot;geo&quot;), all = T)

  temp5[]
</code></pre>

<pre><code>##     age         geo births   pop
##  1:  13 King County      1 12180
##  2:  13    WA State      6 46590
##  3:  14 King County      4 12077
##  4:  14    WA State     16 46446
##  5:  15 King County     10 11943
##  6:  15    WA State     69 45120
##  7:  16 King County     23 12292
##  8:  16    WA State    190 44849
##  9:  17 King County     44 12416
## 10:  17    WA State    348 44562
## 11:  18 King County    111 12776
## 12:  18    WA State    751 45809
## 13:  19 King County    227 13166
## 14:  19    WA State   1481 46540
</code></pre>

<p><strong>Run <code>age_standardize()</code></strong></p>

<pre><code class="r">  ex5.1 &lt;- age_standardize(my.dt = temp5,
                           ref.popname = &quot;World (WHO 2000-2025) Std Million (single ages to 84)&quot;, 
                           collapse = T,
                           my.count = &quot;births&quot;, 
                           my.pop = &quot;pop&quot;, 
                           per = 1000, 
                           conf.level = 0.95, 
                           group_by = &quot;geo&quot;)
  ex5.1[]
</code></pre>

<pre><code>##            geo count    pop crude.rate crude.lci crude.uci adj.rate adj.lci
## 1: King County   420  86850       4.84      4.38      5.32     4.61    4.18
## 2:    WA State  2861 319916       8.94      8.62      9.28     8.82    8.50
##    adj.uci                                         reference_pop
## 1:    5.08 World (WHO 2000-2025) Std Million (single ages to 84)
## 2:    9.15 World (WHO 2000-2025) Std Million (single ages to 84)
</code></pre>

<p>According to your analysis, the crude King County teen birth rate is approximately half (4.84 / 8.94 = 0.541) of the WA State teen birth rate. This relationship remains largely unchanged after age-standardization  (4.61 / 8.82 = 0.523).</p>

<hr/>

<h2>Conclusion</h2>

<p>If you&#39;ve walked through this vignette and more or less understood what&#39;s going on, you&#39;re in good shape! If you&#39;re still confused, please walk through it again and then reach out if you still have questions. Good luck!</p>

</body>

</html>
